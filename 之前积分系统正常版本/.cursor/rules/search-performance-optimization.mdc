---
description: 搜索性能优化
globs: 
alwaysApply: false
---
# 微信小程序搜索性能优化规则

## 概述
针对万能查询页面中不同数据类型搜索性能差异的优化规则，确保所有搜索功能都有良好的用户体验。

## 性能问题分析

### 当前性能差异
- **规章搜索**：快速响应（使用预处理分类数据和智能索引）
- **缩写搜索**：相对卡顿（线性搜索1197条数据，每条检查3个字段）
- **其他搜索**：类似缩写搜索的性能问题

### 根本原因
1. **数据结构差异**：规章使用分类索引，缩写使用原始数组
2. **搜索算法差异**：规章有优化的搜索函数，缩写使用简单filter
3. **预处理程度**：规章数据预处理充分，缩写数据未优化

## 优化策略

### 1. 搜索防抖优化
对所有搜索输入实施防抖机制，避免频繁搜索：

```javascript
// 在页面data中添加防抖定时器
data: {
  searchTimer: null,
  searchDelay: 300 // 300ms防抖延迟
}

// 优化搜索输入处理
onSearchChange(event: any) {
  const searchValue = event.detail
  this.setData({ searchValue })
  
  // 清除之前的定时器
  if (this.data.searchTimer) {
    clearTimeout(this.data.searchTimer)
  }
  
  // 设置新的防抖定时器
  this.setData({
    searchTimer: setTimeout(() => {
      this.performSearch(searchValue)
    }, this.data.searchDelay)
  })
}
```

### 2. 分页搜索优化
对大数据量搜索实施分页加载：

```javascript
// 分页搜索配置
data: {
  searchPageSize: 50,    // 每页显示50条
  searchCurrentPage: 1,  // 当前页
  searchHasMore: true    // 是否有更多数据
}

// 分页搜索实现
performPagedSearch(searchValue: string, page: number = 1) {
  const startIndex = (page - 1) * this.data.searchPageSize
  const endIndex = startIndex + this.data.searchPageSize
  
  // 执行搜索并分页
  const allResults = this.performFullSearch(searchValue)
  const pagedResults = allResults.slice(startIndex, endIndex)
  
  this.setData({
    filteredList: page === 1 ? pagedResults : [...this.data.filteredList, ...pagedResults],
    searchCurrentPage: page,
    searchHasMore: endIndex < allResults.length
  })
}
```

### 3. 搜索索引预处理
为缩写数据创建搜索索引：

```javascript
// 在数据加载时创建搜索索引
createSearchIndex(dataList: any[]) {
  const searchIndex = new Map()
  
  dataList.forEach((item, index) => {
    // 创建搜索关键词集合
    const keywords = [
      item.abbreviation?.toLowerCase(),
      item.english_full?.toLowerCase(),
      item.chinese_translation?.toLowerCase()
    ].filter(Boolean)
    
    keywords.forEach(keyword => {
      // 为每个关键词的前缀创建索引
      for (let i = 1; i <= keyword.length; i++) {
        const prefix = keyword.substring(0, i)
        if (!searchIndex.has(prefix)) {
          searchIndex.set(prefix, new Set())
        }
        searchIndex.get(prefix).add(index)
      }
    })
  })
  
  return searchIndex
}

// 使用索引进行快速搜索
searchWithIndex(searchValue: string, searchIndex: Map, dataList: any[]) {
  const searchLower = searchValue.toLowerCase()
  const matchedIndices = searchIndex.get(searchLower) || new Set()
  
  return Array.from(matchedIndices).map(index => dataList[index])
}
```

### 4. 虚拟列表优化
对搜索结果使用虚拟滚动：

```javascript
// 虚拟列表配置
data: {
  virtualListHeight: 400,     // 可视区域高度
  virtualItemHeight: 80,      // 每项高度
  virtualStartIndex: 0,       // 开始索引
  virtualEndIndex: 10,        // 结束索引
  virtualVisibleItems: []     // 可见项目
}

// 计算可见项目
calculateVisibleItems(scrollTop: number) {
  const startIndex = Math.floor(scrollTop / this.data.virtualItemHeight)
  const endIndex = Math.min(
    startIndex + Math.ceil(this.data.virtualListHeight / this.data.virtualItemHeight) + 1,
    this.data.filteredList.length
  )
  
  const visibleItems = this.data.filteredList.slice(startIndex, endIndex)
  
  this.setData({
    virtualStartIndex: startIndex,
    virtualEndIndex: endIndex,
    virtualVisibleItems: visibleItems
  })
}
```

## 具体实施要求

### 1. 缩写搜索优化
参考 [abbreviations/index.ts](mdc:miniprogram/pages/abbreviations/index.ts)：
- 实施300ms搜索防抖
- 创建缩写数据搜索索引
- 搜索结果分页显示（每页50条）

### 2. 定义搜索优化
- 应用相同的防抖和分页策略
- 针对定义数据的特点优化搜索算法

### 3. 机场搜索优化
- 考虑机场代码的特殊性（ICAO/IATA代码）
- 实施精确匹配优先的搜索策略

### 4. 通信搜索优化
- 保持现有的章节分组功能
- 优化句子搜索的性能

## 性能监控

### 1. 搜索性能埋点
```javascript
// 搜索性能监控
performSearch(searchValue: string) {
  const startTime = Date.now()
  
  // 执行搜索
  const results = this.doSearch(searchValue)
  
  const endTime = Date.now()
  const searchTime = endTime - startTime
  
  // 记录性能数据
  console.log(`搜索耗时: ${searchTime}ms, 结果数量: ${results.length}`)
  
  // 如果搜索时间超过500ms，记录警告
  if (searchTime > 500) {
    console.warn(`搜索性能警告: ${searchValue} 耗时 ${searchTime}ms`)
  }
}
```

### 2. 用户体验指标
- 搜索响应时间 < 300ms（目标）
- 搜索响应时间 < 500ms（可接受）
- 搜索响应时间 > 500ms（需要优化）

## 渐进式优化策略

### 第一阶段：快速优化
1. 实施搜索防抖（立即见效）
2. 添加搜索性能监控
3. 优化最卡顿的缩写搜索

### 第二阶段：深度优化
1. 创建搜索索引
2. 实施分页搜索
3. 优化所有搜索功能

### 第三阶段：高级优化
1. 虚拟列表实现
2. 搜索结果缓存
3. 智能搜索建议

## 兼容性要求

### 1. 离线优先
- 所有优化必须在离线状态下工作
- 搜索索引本地生成和存储
- 不依赖网络API

### 2. 内存管理
- 搜索索引大小控制
- 及时清理搜索缓存
- 避免内存泄漏

### 3. 用户体验
- 搜索过程中显示加载状态
- 大数据量搜索时显示进度
- 搜索无结果时友好提示

## 测试验证

### 1. 性能测试
- 不同数据量下的搜索性能
- 不同搜索关键词的响应时间
- 内存使用情况监控

### 2. 用户体验测试
- 搜索流畅度主观评价
- 搜索结果准确性验证
- 不同设备上的性能表现

## 总结

通过实施这些优化策略，可以显著提升万能查询页面的搜索性能，让所有搜索功能都达到规章搜索的流畅度水平。优化应该渐进式进行，优先解决最明显的性能问题，然后逐步深化优化。

